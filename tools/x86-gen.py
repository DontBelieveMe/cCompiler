import sys, os.path, os
import datetime

path = os.path.abspath(os.path.dirname(__file__))
path = os.path.join(path, '../vendor/opcodes/opcodes')

sys.path.append(path)

import x86

def write_to_output_file(content, filename):
    path = os.path.abspath(os.path.dirname(__file__))
    path = os.path.join(path, filename)

    with open(path, 'w') as f:
        f.write(content)

isa = x86.read_instruction_set(os.path.join(path, 'x86.xml'))

cpp_file = ''
h_file = '''// Generated Source File. Do Not Edit!
// Creation Time: ''' + str(datetime.datetime.now()) + '''
// Generated by tools/x86-gen.py
// Do not include this file in source control!
// It will be created by the build system

#pragma once

#include <cstddef>
#include <vector>
#include <array>
#include <cc/int_types.h>

namespace cc {
    enum class EX86Instruction {
'''

last_instruction_name = None
unique_instruction_number = 0

for instruction in isa:
    for form in instruction.forms:
        if instruction.name != last_instruction_name:
            inst_name_pretty = instruction.name.capitalize()
            h_file += '\t\t' + inst_name_pretty + ' = ' + str(unique_instruction_number) + ',\n'
            unique_instruction_number += 1

        last_instruction_name = instruction.name

h_file += '\t};\n' # Close brace for EX86Instruction enum

operand_types = [
    'xmm0', 'rel8', 'rel32', 'imm4', 'imm8', 'imm16', 'imm32',
    'r8', 'r16', 'r32', 'mm', 'xmm', 'ymm', 'zmm', 'm', 'm8', 'm16',
    'm32', 'm64', 'm80', 'm128', 'm256', 'eax', 'al', 'ax', 'cl', 'r64',
    'constant1', 'constant3', 'k', 'moffs32', 'xmm_k_', 'xmm_k__z_', 'ymm_k_',
    'ymm_k__z_', 'zmm_k_', 'zmm_k__z_', 'k_k_', '_er_', 'm512', 'm128_m64bcst',
    'm256_m64bcst', 'm512_m64bcst', 'm128_m32bcst', 'm256_m32bcst', 'm512_m32bcst',
    '_sae_', 'm128_k__z_', 'm256_k__z_', 'm512_k__z_', 'm64_m32bcst', 'm64_k__z_',
    'vm32y_k_', 'vm32z_k_', 'vm64z_k_', 'vm64y', 'vm32y', 'vm32x',
    'vm64x', 'vm32z', 'm64_k_', 'vm64z', 'm32_k__z_', 'm16_k__z_', 'vm32x_k_',
    'vm64x_k_', 'vm64y_k_', 'm32_k_',
]

h_file += '\n\tenum class EX86Operand {\n'
for operand in operand_types:
    h_file += '\t\t' + operand.capitalize() + ',\n'
h_file += '\t};\n'

h_file += '''
    class X86Register
    {
    private:
        const char* m_name;
        u8 m_value;

    public:
        X86Register(const char* name, u8 v): m_name(name), m_value(v) {}

        static const X86Register Eax;
        static const X86Register Ecx;
        static const X86Register Edx;
        static const X86Register Ebx;
        static const X86Register Esp;
        static const X86Register Ebp;
        static const X86Register Esi;
        static const X86Register Edi;

    public:
        u8 Value() const { return m_value; }
        const char* Name() const { return m_name; }
    };

    class X86InstructionForm
    {
    private:
        static const std::size_t MaxNumOperands = 5;
        static const std::size_t MaxNumOpcodeBytes = 5;

        std::array<u8, MaxNumOpcodeBytes> m_opcodes;
        u8 m_num_opcodes;

        std::array<EX86Operand, MaxNumOperands> m_operands;
        u8 m_num_operands;

    public:
        X86InstructionForm(std::array<u8, MaxNumOpcodeBytes> opcodes, u8 num_opcodes,
                            std::array<EX86Operand, MaxNumOperands> operands, u8 num_operands)
            : m_opcodes(opcodes), m_num_opcodes(num_opcodes), m_operands(operands), m_num_operands(num_operands)
        {
        }

        const std::array<u8, MaxNumOpcodeBytes>& OpcodeBytes() const { return m_opcodes; }
        u8 NumOpcodeBytes() const { return m_num_opcodes; }
    };

    class X86Instruction
    {
    private:
        const char* m_name;
        EX86Instruction m_ins;
        std::vector<X86InstructionForm> m_forms;

    public:
        X86Instruction(const char* name, EX86Instruction ins, const std::vector<X86InstructionForm>& forms)
            : m_name(name), m_forms(forms), m_ins(ins)
        { }

        const char* Name() const { return m_name; }
        const std::vector<X86InstructionForm> Forms() const { return m_forms; }
        EX86Instruction InstructionEnum() const { return m_ins; }
    };

    class X86InstructionSet
    {
    public:
        static constexpr int NumberOfInstructions = ''' + str(unique_instruction_number) + ''';

    private:
        static X86Instruction s_instructions[NumberOfInstructions];

    public:

        static X86Instruction* GetInstructionFromName(const char* name);
    };
'''
h_file += '}\n' # Close brace for cc namespace

cpp_file = '''#include <cc/x86_data.h>
using namespace cc;

const X86Register X86Register::Eax("eax", 0x00);
const X86Register X86Register::Ecx("ecx", 0x01);
const X86Register X86Register::Edx("edx", 0x02);
const X86Register X86Register::Ebx("ebx", 0x03);
const X86Register X86Register::Esp("esp", 0x04);
const X86Register X86Register::Ebp("ebp", 0x05);
const X86Register X86Register::Esi("esi", 0x06);
const X86Register X86Register::Edi("edi", 0x07);

X86Instruction X86InstructionSet::s_instructions[] = {
'''
for instruction in isa:
    inst_name = instruction.name.lower()
    enum_ident = 'EX86Instruction::' + instruction.name.capitalize()

    cpp_file += '\t{\n'
    cpp_file += '\t\t"' + inst_name + '", ' + enum_ident + ',\n\t\t{\n'

    for form in instruction.forms:
        operands = form.operands

        for encoding in form.encodings:
            opcodes = []

            for component in encoding.components:
                if type(component) is x86.Opcode:
                    opcodes.append(component.byte)

                if type(component) is x86.Prefix:
                    opcodes.append(component.byte)

            if len(opcodes) > 0:
                cpp_file += '\t\t\tX86InstructionForm({'

                for op in opcodes:
                    cpp_file += hex(op) + ','

                cpp_file += '}, ' + str(len(opcodes))
                cpp_file += ',\n\t\t\t\t'

                cpp_file += '{'

                for op in operands:
                    t = op.type.replace('{', '_').replace('}', '_').replace('/', '_')

                    if op.type == '1' or op.type == '3':
                        cpp_file += 'EX86Operand::Constant' + op.type + ','
                    else:
                        cpp_file += 'EX86Operand::' + t.capitalize() + ','

                cpp_file += '},' + str(len(operands))

                cpp_file += '\n\t\t\t),\n'

    cpp_file += '\t\t}\n\t},\n'

cpp_file += '};'

write_to_output_file(cpp_file, 'x86_data.cpp')
write_to_output_file(h_file, 'x86_data.h')
